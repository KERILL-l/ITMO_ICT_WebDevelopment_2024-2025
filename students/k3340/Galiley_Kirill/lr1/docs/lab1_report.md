# Лабораторная работа №1  
## Тема: Работа с сокетами (UDP, TCP, HTTP)

**Дисциплина:** Веб-программирование  
**Студент:** *Галилей Кирилл К3340*  
**Вариант:** 2 (решение квадратного уравнения)

---

## Цели и задачи работы

- Освоить базовые принципы работы с сокетами в Python (UDP и TCP).[web:22][web:47]  
- Научиться реализовывать клиент–серверное взаимодействие на низком уровне с помощью библиотеки `socket`.[web:35][web:78]  
- Реализовать простые сетевые приложения: обмен текстовыми сообщениями, математический сервис, HTTP‑сервер и чат, а также веб‑сервер с обработкой форм (GET/POST).[web:21][web:24]  

---

## Теоретические сведения

Сокет — это программный интерфейс для обмена данными между процессами по сети, который связывает IP‑адрес и номер порта.[web:47][web:78]  
В работе используются два типа сокетов:  
- UDP (SOCK_DGRAM) — дейтаграммный, без установления соединения, используется для простого обмена сообщениями.  
- TCP (SOCK_STREAM) — ориентированный на соединение, обеспечивает надежную доставку и упорядоченность байтового потока, используется для чата, математического сервиса и HTTP.[web:22][web:47]  

HTTP‑сервер реализуется поверх TCP: сервер принимает запрос, читает стартовую строку и заголовки и возвращает ответ с кодом состояния, заголовками и телом в формате HTML.[web:35][web:77]  
Для поддержки нескольких клиентов одновременно в чате применяется многопоточность через модуль `threading` и общий список активных подключений.[web:52][web:78]  

---

## Задание 1. UDP обмен сообщениями

**Постановка задачи.**  
Реализовать клиентскую и серверную часть приложения на UDP. Клиент отправляет сообщение «Hello, server», сервер выводит его у себя и отправляет клиенту ответ «Hello, client». Клиент выводит ответ на экран.  

**Реализация.**  
- `server_udp.py`: создает UDP‑сокет, биндится на `127.0.0.1:5000`, в цикле принимает датаграммы через `recvfrom`, выводит текст и отправляет ответ «Hello, client» тому же адресу.[web:40][web:50]  
- `client_udp.py`: создает UDP‑сокет, отправляет на сервер строку «Hello, server» с помощью `sendto`, принимает один ответ и выводит его, после чего закрывает сокет.[web:41][web:43]  

**Результат работы.**  
При запущенном сервере и старте клиента на стороне сервера отображается текст клиента, а на стороне клиента — ответ сервера.  

---

## Задание 2. TCP сервис решения квадратного уравнения (вариант 2)

**Постановка задачи.**  
Реализовать TCP‑клиент и сервер. Клиент вводит коэффициенты квадратного уравнения \(ax^2 + bx + c = 0\), сервер считает корни и возвращает результат. Вариант 2 — решение квадратного уравнения.  

**Реализация.**  
- `quadratic_server.py`:  
  - Создает TCP‑сокет на `127.0.0.1:5001`, выполняет `bind`, `listen`, `accept`.[web:21][web:24]  
  - Принимает строку вида `a b c`, парсит числа, вычисляет дискриминант \(D = b^2 - 4ac\) и в зависимости от знака дискриминанта возвращает: два корня, один корень или сообщение об отсутствии действительных корней.[web:2][web:3]  
  - При `a = 0` сообщает об ошибке, так как уравнение перестает быть квадратным.  
- `quadratic_client.py`:  
  - Запрашивает у пользователя `a`, `b`, `c`, соединяется с сервером через TCP и отправляет все три коэффициента одной строкой.  
  - Получает строковый ответ сервера и выводит его пользователю.[web:23][web:32]  

**Результат работы.**  
Клиент и сервер успешно обмениваются данными, вычисленные корни корректно отображаются на стороне клиента для разных наборов коэффициентов.  

---

## Задание 3. Простейший HTTP‑сервер

**Постановка задачи.**  
Реализовать серверную часть приложения, который по подключению клиента возвращает HTTP‑сообщение с HTML‑страницей, загружаемой из файла `index.html`.  

**Реализация.**  
- Создан файл `index.html` с простой HTML‑страницей, содержащей заголовок и текст приветствия.  
- `http_server.py`:  
  - Поднимает TCP‑сервер на `127.0.0.1:5002`, принимает входящее соединение, читает HTTP‑запрос из сокета.[web:24][web:28]  
  - Считывает содержимое `index.html` с диска, формирует HTTP‑ответ: строку статуса `HTTP/1.1 200 OK`, заголовки (`Content-Type`, `Content-Length`, `Connection`) и тело с HTML.[web:35][web:77]  
  - Отправляет ответ клиенту и закрывает соединение.  

**Результат работы.**  
При открытии в браузере адреса `http://127.0.0.1:5002/` отображается содержимое `index.html`, отданное через самописный HTTP‑сервер на сокетах.  

---

## Задание 4. Многопользовательский чат (TCP + потоки)

**Постановка задачи.**  
Реализовать чат с поддержкой нескольких пользователей. Сервер должен принимать несколько одновременных подключений, а сообщения от одного клиента пересылать всем остальным. Для максимального количества баллов требуется многопользовательский чат на TCP с использованием `threading`.  

**Реализация.**  
- `chat_server.py`:  
  - Создает TCP‑сервер на `127.0.0.1:5003`, слушает порт и при каждом новом подключении создает поток `threading.Thread` для обработки клиента.[web:44][web:52]  
  - Ведет общий список клиентских сокетов, защищенный блокировкой `Lock`, и реализует функцию `broadcast`, рассылающую входящие сообщения всем клиентам, кроме отправителя.  
  - При отключении клиента удаляет его сокет из списка и закрывает соединение.  
- `chat_client.py`:  
  - Подключается к серверу по TCP и запускает отдельный поток для постоянного чтения входящих сообщений и вывода их на экран.[web:46][web:48]  
  - В основном потоке читает ввод пользователя из консоли и отправляет его на сервер; предусмотрена команда `/quit` для выхода.  

**Результат работы.**  
При запуске нескольких клиентов на одном или разных хостах сообщения, отправленные одним пользователем, отображаются у всех остальных подключенных клиентов, что подтверждает корректную работу многопользовательского чата.  

---

## Задание 5. Веб‑сервер для работы с оценками (GET и POST)

**Постановка задачи.**  
Реализовать простой веб‑сервер на сокетах, который:  
- Принимает и сохраняет информацию о дисциплине и оценке по дисциплине через HTTP POST‑запрос.  
- Отдает HTML‑страницу со списком всех накопленных оценок по дисциплинам через HTTP GET‑запрос.  

**Реализация.**  
- `grade_server.py`:  
  - Поднимает TCP‑сервер на `127.0.0.1:5004` и хранит оценки в списке словарей в оперативной памяти.  
  - На `GET /` формирует HTML‑страницу, содержащую форму с полями для ввода дисциплины и оценки, а также таблицу со всеми уже сохраненными оценками.  
  - На `POST /` парсит тело запроса как URL‑кодированную форму (`application/x-www-form-urlencoded`), извлекает поля `subject` и `grade`, добавляет новую запись в список и затем возвращает обновленную HTML‑страницу.[web:6][web:10][web:35]  
  - Ответы формируются с корректными HTTP‑заголовками и кодировкой UTF‑8.  

**Результат работы.**  
При открытии `http://127.0.0.1:5004/` в браузере отображается форма и таблица оценок; при отправке формы с новой дисциплиной и оценкой запись добавляется в список и тут же появляется в таблице.  

---

## Тестирование

Для проверки корректной работы всех заданий были выполнены следующие действия:  
- Для задания 1 запускались сервер и клиент, контролировались передаваемые строки в консоли.[web:40][web:43]  
- Для задания 2 тестировались различные наборы коэффициентов: с двумя корнями, с одним корнем (D=0) и с отрицательным дискриминантом, проверялся текст ответа сервера.[web:2][web:3]  
- Для задания 3 и 5 использовался браузер (HTTP GET/POST), проверялась корректность ответов и отображение страниц.  
- Для задания 4 запускались минимум два клиента, проверялась доставка сообщений всем участникам чата.  

---

## Выводы

В ходе лабораторной работы были реализованы несколько типов сетевых приложений на языке Python, использующих UDP‑ и TCP‑сокеты, а также простой HTTP‑сервер и многопользовательский чат.[web:21][web:22]  
Получены практические навыки создания клиент–серверных приложений, обработки текстовых протоколов (HTTP), организации многопоточности на стороне сервера и обработки формальных данных (коэффициенты уравнения, оценки по дисциплинам).[web:24][web:35][web:52]  
